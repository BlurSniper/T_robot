<!doctype html>
<html>
<head>
    <title>learningthree.js boiler plate for three.js</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">


    <script src="vendor/three.js/Three.js"></script>
    <script src="vendor/three.js/Detector.js"></script>
    <!-- https://github.com/mrdoob/stats.js -->
    <script src="vendor/three.js/Stats.js"></script>

    <script src="vendor/threex/THREEx.screenshot.js"></script>
    <script src="vendor/threex/THREEx.FullScreen.js"></script>
    <script src="vendor/threex/THREEx.WindowResize.js"></script>
    <script src="vendor/three.js/OrbitControls.js"></script>
    <script src="vendor/three.js/TransformControls.js"></script>

    <link href="css/main.css" rel="stylesheet"/>
</head>
<body>
<!-- three.js container -->
<div id="container"></div>
<!-- info on screen display -->


<script type="text/javascript">
    var stats, scene, renderer, composer;
    var camera, cameraControls;

    init();

    // init the scene
    function init() {

        var V_initial = [ [ 1, 1, 0 ], [ 0, 10, 0 ], [ 5, 0, 0 ], [ 0, 4, 0 ], [ 0, - 3, 0 ], [ 0, 0, 0 ] ]
//        V_initial = [ [ 1, 1, 2 ], [ 0, 10, 0 ], [ 0, 0, -5 ], [ 5, 0, 0 ], [ 0, - 3, 0 ] ]
//        V_initial = [ [ 1, 1, 2 ], [ 0, 10, 0 ], [ 0, 3, -5 ], [ 1, 0, -3 ], [ 0, - 3, 0 ] ]
//        V_initial = [ [ 5, 0, 0 ], [ 0, 5, 0 ], [ 0, 0, 5 ], [ 5, 0, 0 ], [ 0, - 3, 0 ] ]
//        V_initial = [ [ -3, -5, -7 ], [ 15, -4, 3 ], [ 2, -5, -8 ], [ -10, -3, -2 ], [ 0, - 3, 0 ] ]

        if ( Detector.webgl ) {
            renderer = new THREE.WebGLRenderer( {
                antialias: true,	// to get smoother output
                preserveDrawingBuffer: true	// to allow screenshot
            } );
            renderer.setClearColor( 0xbbbbbb );
        } else {
            Detector.addGetWebGLMessage();
            return true;
        }
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.getElementById( 'container' ).appendChild( renderer.domElement );


        // create a scene
        scene = new THREE.Scene();

        // put a camera in the scene
        camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 10000 );
        camera = new THREE.OrthographicCamera( - 15, 15, 15, - 12, 1, 1000 );
        camera.position.set( - 25, 25, 25 );
        scene.add( camera );

        var cameraControls = new THREE.OrbitControls( camera, container.dom );
        cameraControls.addEventListener( 'change', render )

        var control = new THREE.TransformControls( camera, renderer.domElement );
        control.addEventListener( 'change', function () {
            setTarget( target.position )
            render()
        } );
        scene.add( control )

        // transparently support window resize
        THREEx.WindowResize.bind( renderer, camera );


        // here you add your objects
        // - you will most likely replace this part by your own
        var light = new THREE.AmbientLight( Math.random() * 0xffffff );
        scene.add( light );
        var light = new THREE.DirectionalLight( Math.random() * 0xffffff );
        light.position.set( Math.random(), Math.random(), Math.random() ).normalize();
        scene.add( light );

        let sphereGeo = new THREE.SphereGeometry( .9, 32, 32 );
        var target = new THREE.Mesh( sphereGeo, new THREE.MeshBasicMaterial( {
            transparent: true, opacity: 0.7, color: 0xff0000
        } ) );
        scene.add( target )
        control.attach( target )

        var calculatedJointGeometry = []

        for ( var i = 0; i < 6; i ++ ) {
            let sphereGeom = new THREE.SphereGeometry( 1, 32, 32 );
            let sphereM = new THREE.Mesh( sphereGeom, new THREE.MeshBasicMaterial( {
                transparent: true, opacity: 0.5, color: 0xfff50
            } ) );
            scene.add( sphereM )
            calculatedJointGeometry.push( sphereM )

        }


        let x = 0, y = 0, z = 0;

        let robotGeometryObjects = [];
        let parentObject = scene;
        for ( let link of V_initial ) {

            let linkGeo = createCube( x, y, z, link[ 0 ], link[ 1 ], link[ 2 ], robotGeometryObjects.length )
            x = link[ 0 ]
            y = link[ 1 ]
            z = link[ 2 ]
            parentObject.add( linkGeo )
            parentObject = linkGeo
            robotGeometryObjects.push( linkGeo )
        }


        function createCube( x, y, z, w, h, d, jointNumber ) {
            let thicken = 1
            console.log( x, y, z, w, h, d )
            var w_thickened = Math.abs( w ) + thicken
            var h_thickened = Math.abs( h ) + thicken
            var d_thickened = Math.abs( d ) + thicken
            var material = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
            var geometry = new THREE.CubeGeometry( w_thickened, h_thickened, d_thickened );
            var mesh = new THREE.Mesh( geometry, material );
            mesh.position.set( w / 2, h / 2, d / 2 )
            let group = new THREE.Object3D()
            group.position.set( x, y, z )
            group.add( mesh )

            let jointGeo = new THREE.CylinderGeometry( .8, .8, .8 * 2, 32 );
            var joint = new THREE.Mesh( jointGeo, new THREE.MeshBasicMaterial( { color: 0xffff00 } ) );
            if ( jointNumber == 1 || jointNumber == 2 || jointNumber == 4 ) {

                joint.rotation.x = Math.PI / 2
            }
            if ( jointNumber == 3 ) {

                joint.rotation.z = Math.PI / 2
            }
// joint.position.set(x,y,z)

            group.add( joint )
            return group

        }

        var arrows = {}

        function addArrow( name, from, to ) {
            if ( arrows.hasOwnProperty( name ) ) {
                scene.remove( arrows[ name ] )
            }
            var dir = new THREE.Vector3( to[ 0 ], to[ 1 ], to[ 2 ] );
            var origin = new THREE.Vector3( from[ 0 ], from[ 1 ], from[ 2 ] );
            var length = dir.sub( origin ).length()
            dir.normalize()
            var color = 0xffff00;
            arrows[ name ] = new THREE.ArrowHelper( dir, origin, length, color, 2, 1 );
            scene.add( arrows[ name ] );
        }

//        setInterval( function () {
//            robotGeometryObjects[ 0 ].rotation.y += 1 / 180 * Math.PI
//            robotGeometryObjects[ 1 ].rotation.z += 1 / 180 * Math.PI
//            robotGeometryObjects[ 2 ].rotation.z += 1 / 180 * Math.PI
//            robotGeometryObjects[ 3 ].rotation.x += 1 / 180 * Math.PI
//            render()
//        }, 500 )


        var size = 10;
        var step = 20;

        var gridHelper = new THREE.GridHelper( size, step );
        scene.add( gridHelper );

        var axisHelper = new THREE.AxisHelper( 5 );
        scene.add( axisHelper );

        var target_A = []

        function setTarget( position ) {

            inverseKinematics( position.x, position.y, position.z, 0, 0, 1 )
            robotGeometryObjects[ 0 ].rotation.y = target_A[ 0 ]
            robotGeometryObjects[ 1 ].rotation.z = target_A[ 1 ]
            robotGeometryObjects[ 2 ].rotation.z = target_A[ 2 ]
//            robotGeometryObjects[ 3 ].rotation.x = target_A[ 3 ]
        }

        var selectedJoint = 0
        window.addEventListener( 'keydown', function myFunction( event ) {
//            Up: 38
//            Down: 40
//            Right: 39
//            Left: 37
            console.log( event.keyCode )
            if ( event.keyCode >= 48 && event.keyCode <= 57 ) {
                console.log( 'selected Joint:' + (event.keyCode - 48) )
                selectedJoint = event.keyCode - 48
            }
            switch ( event.keyCode ) {
                case 38:
                    console.log( "Up key is pressed" );
                    break;
                case 40:
                    console.log( "Down key is pressed" );
                    break;
                case 39:
                    console.log( "Right key is pressed" );
                    break;
                case 37:
                    console.log( "left key is pressed" );
                    break;
                case 65:
                    console.log( selectedJoint + "rotate left" );
                    robotGeometryObjects[ selectedJoint ].rotation[ (selectedJoint == 3) ? 'x' : 'z' ] -= 5 / 180 * Math.PI
                    break;
                case 68:
                    console.log( selectedJoint + "rotate right" );
                    robotGeometryObjects[ selectedJoint ].rotation[ (selectedJoint == 3) ? 'x' : 'z' ] += 5 / 180 * Math.PI
                    break;
            }
            setTarget( target.position ) //to do ik again
            render()
        }, false )

        var V_length_x_y = []
        V_length_x_y[ 0 ] = Math.sqrt( Math.pow( V_initial[ 0 ][ 0 ], 2 ) + Math.pow( V_initial[ 0 ][ 1 ], 2 ) );
        V_length_x_y[ 1 ] = Math.sqrt( Math.pow( V_initial[ 1 ][ 0 ], 2 ) + Math.pow( V_initial[ 1 ][ 1 ], 2 ) );
        V_length_x_y[ 2 ] = Math.sqrt( Math.pow( V_initial[ 2 ][ 0 ], 2 ) + Math.pow( V_initial[ 2 ][ 1 ], 2 ) );
        V_length_x_y[ 3 ] = Math.sqrt( Math.pow( V_initial[ 3 ][ 0 ], 2 ) + Math.pow( V_initial[ 3 ][ 1 ], 2 ) );

        var jointLimits = [ [ - 180, 180 ], [ - 180, 180 ], [ - 180, 180 ], [ - 180, 180 ], [ - 180, 180 ], [ - 180, 180 ] ]

        var J_initial = []
        var tmpPos = [ 0, 0, 0 ]
        for ( var i = 0; i < V_initial.length; i ++ ) {

            J_initial.push( [ tmpPos[ 0 ], tmpPos[ 1 ], tmpPos[ 2 ] ] )
            tmpPos[ 0 ] += V_initial[ i ][ 0 ]
            tmpPos[ 1 ] += V_initial[ i ][ 1 ]
            tmpPos[ 2 ] += V_initial[ i ][ 2 ]
        }

        var Serial = {
            println: function ( text ) {
                console.log( text )
            }
        }

        function floatToString( float ) {
            return '' + float
        }

        function length3( vector ) {
            return Math.sqrt( Math.pow( vector[ 0 ], 2 ) + Math.pow( vector[ 1 ], 2 ) + Math.pow( vector[ 2 ], 2 ) )
        }

        function length2( a, b ) {
            return Math.sqrt( Math.pow( a, 2 ) + Math.pow( b, 2 ) )
        }

        function getClosestPointToVector( V, P ) {

            var atb2 = V[ 0 ] * V[ 0 ] + V[ 1 ] * V[ 1 ]  // **2 means "squared"
            //   Basically finding the squared magnitude
            //   of a_to_b

            var atp_dot_atb = P[ 0 ] * V[ 0 ] + P[ 1 ] * V[ 1 ]
            // The dot product of a_to_p and a_to_b

            var t = atp_dot_atb / atb2              // The normalized "distance" from a to
            //   your closest point

            return [ V[ 0 ] * t, V[ 1 ] * t ]
            // Add the distance to A, moving
            //   towards B

        }

        // visualize 3,4 Axis constraints

        let sphereGeom = new THREE.SphereGeometry( V_length_x_y[ 3 ], 32, 32 );
        let V3_rotationsphere = new THREE.Mesh( sphereGeom, new THREE.MeshBasicMaterial( {
            transparent: true, opacity: 0.3, color: 0xffcc37
        } ) );
//        robotGeometryObjects[ 4 ].add( V3_rotationsphere )
        scene.add( V3_rotationsphere )

        var geometry = new THREE.PlaneGeometry( 20, 20, 1 );
        var material = new THREE.MeshBasicMaterial( {
            color: 0x72db67, side: THREE.DoubleSide, transparent: true, opacity: 0.3
        } );

        var planeMesh = new THREE.Mesh( geometry, material );
        var plane = new THREE.Group()
        planeMesh.position.set( 10, 10, 0 )
        plane.add( planeMesh )
        scene.add( plane );

        var material2 = new THREE.MeshBasicMaterial( {
            color: 0x72fff7, side: THREE.DoubleSide, transparent: true, opacity: 0.3
        } );
        var plane_projected_Mesh = new THREE.Mesh( geometry, material2 );
        var plane_projected_ = new THREE.Group()
        plane_projected_Mesh.position.set( 10, 10, 0 )
        plane_projected_.add( plane_projected_Mesh )
        scene.add( plane_projected_ );

        robotGeometryObjects[ 1 ].children[ 0 ].material.visible = false;
        robotGeometryObjects[ 2 ].children[ 0 ].material.visible = false;

        var radius = V_length_x_y[ 3 ], segments = 64, circleMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff } ), circleGeometry = new THREE.CircleGeometry( radius, segments );

// Remove center vertex
        circleGeometry.vertices.shift();
        var circle = new THREE.Line( circleGeometry, circleMaterial )
        scene.add( circle );


        function inverseKinematics( x, y, z, u, v, w ) {

            console.log( x, y, z )
            var vector = [ 1, 0, 0 ];
            //normalise
            var vLength = Math.sqrt( Math.pow( vector[ 0 ], 2 ) + Math.pow( vector[ 1 ], 2 ) + Math.pow( vector[ 2 ], 2 ) );
            vector[ 0 ] /= vLength;
            vector[ 1 ] /= vLength;
            vector[ 2 ] /= vLength;

            var A = [ 0, 0, 0, 0, 0, 0 ];

            var J = [ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ];

            // ---- J5 ----

            J[ 5 ][ 0 ] = x;
            J[ 5 ][ 1 ] = y;
            J[ 5 ][ 2 ] = z;

            calculatedJointGeometry[ 5 ].position.set( x, y, z )

            // ---- J4 ----
//todo use direction
            J[ 4 ][ 0 ] = x - V_length_x_y[ 3 ] * vector[ 0 ];
            J[ 4 ][ 1 ] = y - V_length_x_y[ 3 ] * vector[ 1 ];
            J[ 4 ][ 2 ] = z - V_length_x_y[ 3 ] * vector[ 2 ];

            J[ 4 ][ 0 ] = x;
            J[ 4 ][ 1 ] = y - 1;
            J[ 4 ][ 2 ] = z;

            calculatedJointGeometry[ 4 ].position.set( J[ 4 ][ 0 ], J[ 4 ][ 1 ], J[ 4 ][ 2 ] )

            // todo backwards rotation

            // ---- J3 ----
            J[ 3 ][ 0 ] = x;
            J[ 3 ][ 1 ] = y - 1;
            J[ 3 ][ 2 ] = z;


//            // ---- A0 ----
//            // # J4
//
//            // correct by z offset of bones
//            A[ 0 ] += Math.PI / 2 - Math.acos( J_initial[ 4 ][ 2 ] / length2( J[ 4 ][ 2 ], J[ 4 ][ 0 ] ) )
//
//            A[ 0 ] += Math.atan2( - J[ 4 ][ 2 ], J[ 4 ][ 0 ] );
//
//            if ( J_initial[ 4 ][ 2 ] > length2( J[ 4 ][ 2 ], J[ 4 ][ 0 ] ) ) {
//                Serial.println( "out of reach" )
//            }

            // ---- A0 ----
            // # J3

            // correct by z offset of bones
            A[ 0 ] += Math.PI / 2 - Math.acos( J_initial[ 3 ][ 2 ] / length2( J[ 3 ][ 2 ], J[ 3 ][ 0 ] ) )

            A[ 0 ] += Math.atan2( - J[ 3 ][ 2 ], J[ 3 ][ 0 ] );

            if ( J_initial[ 3 ][ 2 ] > length2( J[ 3 ][ 2 ], J[ 3 ][ 0 ] ) ) {
                Serial.println( "out of reach" )
            }

            plane.rotation.y = A[ 0 ]
            // ---- J1 ----
            // # A0

            J[ 1 ][ 0 ] = Math.cos( A[ 0 ] ) * V_initial[ 0 ][ 0 ] + Math.sin( A[ 0 ] ) * V_initial[ 0 ][ 2 ];
            J[ 1 ][ 1 ] = V_initial[ 0 ][ 1 ];
            J[ 1 ][ 2 ] = - Math.sin( A[ 0 ] ) * V_initial[ 0 ][ 0 ] + Math.cos( A[ 0 ] ) * V_initial[ 0 ][ 2 ];

            calculatedJointGeometry[ 1 ].position.set( J[ 1 ][ 0 ], J[ 1 ][ 1 ], J[ 1 ][ 2 ] )


//            // ---- rotate J4 into x,y plane ----
//            // # J4 A0
//
//            var J4_x_y = []
//
//            calculatedJointGeometry[ 5 ].position.set( 10 * ( + Math.sin( A[ 0 ] ) ), 3, 10 * ( + Math.cos( A[ 0 ] )) )
//
//            J4_x_y[ 0 ] = Math.cos( A[ 0 ] ) * J[ 4 ][ 0 ] + -Math.sin( A[ 0 ] ) * J[ 4 ][ 2 ];
//            J4_x_y[ 1 ] = J[ 4 ][ 1 ];
//            J4_x_y[ 2 ] = Math.sin( A[ 0 ] ) * J[ 4 ][ 0 ] + Math.cos( A[ 0 ] ) * J[ 4 ][ 2 ];
//
//            addArrow( 'J4_x_y', J[ 0 ], J4_x_y )

            // ---- rotate J3 into x,y plane ----
            // # J3 A0

            var J3_x_y = []

            calculatedJointGeometry[ 5 ].position.set( 10 * ( + Math.sin( A[ 0 ] ) ), 3, 10 * ( + Math.cos( A[ 0 ] )) )

            J3_x_y[ 0 ] = Math.cos( A[ 0 ] ) * J[ 3 ][ 0 ] + - Math.sin( A[ 0 ] ) * J[ 3 ][ 2 ];
            J3_x_y[ 1 ] = J[ 3 ][ 1 ];
            J3_x_y[ 2 ] = Math.sin( A[ 0 ] ) * J[ 3 ][ 0 ] + Math.cos( A[ 0 ] ) * J[ 3 ][ 2 ];

            addArrow( 'J3_x_y', J[ 0 ], J3_x_y )


//            // ---- A2 ----
//            // # J4 todo use J3, J4 may be rotated out of axis
//
//            // setup geometry todo can be cached
//            A[ 2 ] -= Math.PI / 2
//            A[ 2 ] -= Math.atan2( (V_initial[ 2 ][ 1 ] + V_initial[ 3 ][ 1 ]), (V_initial[ 2 ][ 0 ] + V_initial[ 3 ][ 0 ]) ) // correct offset bone V2,V3
//            A[ 2 ] -= Math.atan2( V_initial[ 1 ][ 0 ], V_initial[ 1 ][ 1 ] ) //correct bone offset of V1
//            //end todo
//
//            var J1J4_projected_length_square = Math.pow( J4_x_y[ 0 ] - J_initial[ 1 ][ 0 ], 2 ) + Math.pow( J4_x_y[ 1 ] - J_initial[ 1 ][ 1 ], 2 ); //not using Math.sqrt
//            //Serial.println("A2 " + floatToString(J1J4_projected_length_square));
//            var J2J4_length_x_y = length2( V_initial[ 2 ][ 0 ] + V_initial[ 3 ][ 0 ], V_initial[ 2 ][ 1 ] + V_initial[ 3 ][ 1 ] )
//            A[ 2 ] += Math.acos( (- J1J4_projected_length_square + Math.pow( J2J4_length_x_y, 2 ) + Math.pow( V_length_x_y[ 1 ], 2 )) / (2.0 * (J2J4_length_x_y) * V_length_x_y[ 1 ]) );
//
//
//            console.log( '%c ' + Math.asin( (V_initial[ 2 ][ 1 ] + V_initial[ 3 ][ 1 ]) / (length2( V_initial[ 2 ][ 0 ] + V_initial[ 3 ][ 0 ], V_initial[ 2 ][ 1 ] + V_initial[ 3 ][ 1 ] )) ), 'color: #bada55' );
//            console.log( '%c ' + J2J4_length_x_y, 'color: red' );
//            addArrow( 'J2J4_length_x_y', [ 0, 0, 0 ], [ J2J4_length_x_y, 0, 0 ] )

            // ---- A2 ----
            // # J3 todo use J3, J4 may be rotated out of axis

            // setup geometry todo can be cached
            A[ 2 ] -= Math.PI / 2
            A[ 2 ] -= Math.atan2( (V_initial[ 2 ][ 1 ] ), (V_initial[ 2 ][ 0 ] ) ) // correct offset bone V2,V3
            A[ 2 ] -= Math.atan2( V_initial[ 1 ][ 0 ], V_initial[ 1 ][ 1 ] ) //correct bone offset of V1
            //end todo

            var J1J3_projected_length_square = Math.pow( J3_x_y[ 0 ] - J_initial[ 1 ][ 0 ], 2 ) + Math.pow( J3_x_y[ 1 ] - J_initial[ 1 ][ 1 ], 2 ); //not using Math.sqrt
            //Serial.println("A2 " + floatToString(J1J4_projected_length_square));
            var J2J3_length_x_y = length2( V_initial[ 2 ][ 0 ], V_initial[ 2 ][ 1 ] )
            A[ 2 ] += Math.acos( (- J1J3_projected_length_square + Math.pow( J2J3_length_x_y, 2 ) + Math.pow( V_length_x_y[ 1 ], 2 )) / (2.0 * (J2J3_length_x_y) * V_length_x_y[ 1 ]) );


            console.log( '%c ' + Math.asin( (V_initial[ 2 ][ 1 ] ) / (length2( V_initial[ 2 ][ 0 ], V_initial[ 2 ][ 1 ] )) ), 'color: #bada55' );
            console.log( '%c ' + J2J3_length_x_y, 'color: red' );
            addArrow( 'J2J4_length_x_y', [ 0, 0, 0 ], [ J2J3_length_x_y, 0, 0 ] )

//            // ---- A1 ----
//            // # J4
//
//            // setup geometry
//            A[ 1 ] -= Math.PI * 0.5
//            A[ 1 ] += Math.atan2( V_initial[ 1 ][ 0 ], V_initial[ 1 ][ 1 ] ) // correct offset bone
//
//            var J1J4_projected_length = Math.sqrt( J1J4_projected_length_square );
//            A[ 1 ] += Math.atan2( (J4_x_y[ 1 ] - J_initial[ 1 ][ 1 ]), ( J4_x_y[ 0 ] - J_initial[ 1 ][ 0 ] ) )
//            A[ 1 ] += Math.acos( (+ J1J4_projected_length_square - Math.pow( J2J4_length_x_y, 2 ) + Math.pow( V_length_x_y[ 1 ], 2 )) / (2.0 * J1J4_projected_length * V_length_x_y[ 1 ]) );

            // ---- A1 ----
            // # J3

            // setup geometry
            A[ 1 ] -= Math.PI * 0.5
            A[ 1 ] += Math.atan2( V_initial[ 1 ][ 0 ], V_initial[ 1 ][ 1 ] ) // correct offset bone

            var J1J3_projected_length = Math.sqrt( J1J3_projected_length_square );
            A[ 1 ] += Math.atan2( (J3_x_y[ 1 ] - J_initial[ 1 ][ 1 ]), ( J3_x_y[ 0 ] - J_initial[ 1 ][ 0 ] ) )
            A[ 1 ] += Math.acos( (+ J1J3_projected_length_square - Math.pow( J2J3_length_x_y, 2 ) + Math.pow( V_length_x_y[ 1 ], 2 )) / (2.0 * J1J3_projected_length * V_length_x_y[ 1 ]) );


            // ---- J2 ----
            // # A1 A0 todo does not work

//            J[ 2 ][ 0 ] = Math.cos( A[ 0 ] ) * (V_initial[ 0 ][ 0 ] + Math.cos( A[ 1 ] ) * V_length_x_y[ 1 ]);
//            J[ 2 ][ 1 ] = Math.sin( A[ 0 ] ) * (V_initial[ 0 ][ 0 ] + Math.cos( A[ 1 ] ) * V_length_x_y[ 1 ]);
//            J[ 2 ][ 2 ] = Math.sin( A[ 1 ] ) * V_length_x_y[ 1 ] + V_initial[ 0 ][ 1 ];
//            addArrow( 'J2', J[ 2 ], [ 10, 10, 0 ] )

            // ---- J5 ----

            scene.updateMatrixWorld();
            var J5vector = new THREE.Vector3();
            J5vector.setFromMatrixPosition( robotGeometryObjects[ 5 ].matrixWorld );

            J[ 5 ][ 0 ] = J5vector.x
            J[ 5 ][ 1 ] = J5vector.y
            J[ 5 ][ 2 ] = J5vector.z

            // ---- J4 ----

            var matrix = new THREE.Matrix4();
            matrix.extractRotation( robotGeometryObjects[ 4 ].matrixWorld );

            var direction = new THREE.Vector3( V_initial[ 4 ][ 0 ], V_initial[ 4 ][ 1 ], V_initial[ 4 ][ 2 ] );
            direction.applyMatrix4( matrix )

            J[ 4 ][ 0 ] = J5vector.x - direction.x
            J[ 4 ][ 1 ] = J5vector.y - direction.y
            J[ 4 ][ 2 ] = J5vector.z - direction.z

            V3_rotationsphere.position.set( J[ 4 ][ 0 ], J[ 4 ][ 1 ], J[ 4 ][ 2 ] )
            calculatedJointGeometry[ 4 ].position.set( J[ 4 ][ 0 ], J[ 4 ][ 1 ], J[ 4 ][ 2 ] )

            circle.position.set( J[ 4 ][ 0 ], J[ 4 ][ 1 ], J[ 4 ][ 2 ] )

            var J3vector = new THREE.Vector3();
            J3vector.setFromMatrixPosition( robotGeometryObjects[ 2 ].matrixWorld );

            addArrow( 'J3 vector', J[ 3 ], [ J3vector.x, J3vector.y, J3vector.z ] )

            // ---- A4 ----


            var J2J4 = [ J[ 4 ][ 0 ] - J[ 2 ][ 0 ], J[ 4 ][ 1 ] - J[ 2 ][ 1 ], J[ 4 ][ 2 ] - J[ 2 ][ 2 ], ];

            A[ 4 ] = Math.acos( (J2J4[ 0 ] * vector[ 0 ] + J2J4[ 1 ] * vector[ 1 ] + J2J4[ 2 ] * vector[ 2 ]) / (V_length_x_y[ 2 ] * 1.0) );


            // ---- A3 ----

            var J4J5 = [ J[ 5 ][ 0 ] - J[ 4 ][ 0 ], J[ 5 ][ 1 ] - J[ 4 ][ 1 ], J[ 5 ][ 2 ] - J[ 4 ][ 2 ], ];

            var normal_J2J4_vector = [ J2J4[ 1 ] * J4J5[ 2 ] - J2J4[ 2 ] * J4J5[ 1 ], J2J4[ 2 ] * J4J5[ 0 ] - J2J4[ 0 ] * J4J5[ 2 ], J2J4[ 0 ] * J4J5[ 1 ] - J2J4[ 1 ] * J4J5[ 0 ] ];

            var normal_J2J4_zAxis = [ J2J4[ 1 ] * 1 - J2J4[ 2 ] * 0, J2J4[ 2 ] * 0 - J2J4[ 0 ] * 1, J2J4[ 0 ] * 0 - J2J4[ 1 ] * 0 ];


            if ( normal_J2J4_vector[ 2 ] < 0 ) { //vector points in negative direction
                // normal_J2J4_vector[2] = -normal_J2J4_vector[2];
            }


            A[ 3 ] = Math.acos( (
                    normal_J2J4_zAxis[ 0 ] * normal_J2J4_vector[ 0 ] + normal_J2J4_zAxis[ 1 ] * normal_J2J4_vector[ 1 ] + normal_J2J4_zAxis[ 2 ] * normal_J2J4_vector[ 2 ]) / (
                            Math.sqrt( Math.pow( normal_J2J4_vector[ 0 ], 2 ) + Math.pow( normal_J2J4_vector[ 1 ], 2 ) + Math.pow( normal_J2J4_vector[ 2 ], 2 ) ) * Math.sqrt( Math.pow( normal_J2J4_zAxis[ 0 ], 2 ) + Math.pow( normal_J2J4_zAxis[ 1 ], 2 ) + Math.pow( normal_J2J4_zAxis[ 2 ], 2 ) )
                    ) );


            // A[3] = atan2(vector2.y, vector2.x) - atan2(vector1.y, vector1.x);
            //atan2(norm(cross(a, b)), dot(a, b))
            var cross_normal_J2J4_vector_normal_J2J4_zAxis = [ normal_J2J4_vector[ 1 ] * normal_J2J4_zAxis[ 2 ] - normal_J2J4_vector[ 2 ] * normal_J2J4_zAxis[ 1 ], normal_J2J4_vector[ 2 ] * normal_J2J4_zAxis[ 0 ] - normal_J2J4_vector[ 0 ] * normal_J2J4_zAxis[ 2 ], normal_J2J4_vector[ 0 ] * normal_J2J4_zAxis[ 1 ] - normal_J2J4_vector[ 1 ] * normal_J2J4_zAxis[ 0 ] ];

            var norm = Math.sqrt( Math.pow( cross_normal_J2J4_vector_normal_J2J4_zAxis[ 0 ], 2 ) + Math.pow( cross_normal_J2J4_vector_normal_J2J4_zAxis[ 1 ], 2 ) + Math.pow( cross_normal_J2J4_vector_normal_J2J4_zAxis[ 2 ], 2 ) );

            A[ 3 ] = Math.atan2( norm, (
            normal_J2J4_zAxis[ 0 ] * normal_J2J4_vector[ 0 ] + normal_J2J4_zAxis[ 1 ] * normal_J2J4_vector[ 1 ] + normal_J2J4_zAxis[ 2 ] * normal_J2J4_vector[ 2 ]) );

            /*
             |
             |
             ---- +---- > J2J4_zAxis
             |
             |
             */
            if ( normal_J2J4_vector[ 2 ] > 0 ) {
                Serial.println( "T01 " + floatToString( normal_J2J4_vector[ 0 ] ) );
                Serial.println( "T02 " + floatToString( normal_J2J4_vector[ 1 ] ) );
                Serial.println( "T03 " + floatToString( normal_J2J4_vector[ 2 ] ) );

                //A[3] = -A[3];
            }

            if ( isNaN( A[ 3 ] ) )
                A[ 3 ] = 0;

            //var sign = Mathf.Sign(Vector3.Dot(n,Vector3.Cross(a,b)));
            var tmp = normal_J2J4_zAxis[ 0 ] * cross_normal_J2J4_vector_normal_J2J4_zAxis[ 0 ] + normal_J2J4_zAxis[ 1 ] * cross_normal_J2J4_vector_normal_J2J4_zAxis[ 1 ] + normal_J2J4_zAxis[ 2 ] * cross_normal_J2J4_vector_normal_J2J4_zAxis[ 2 ];

            var sign = (tmp > 0) ? 1.0 : - 1.0;

            Serial.println( (sign == - 1.0) ? "NEEGATIVVEE!!" : "POSITIVVEE!!!" );
            // angle in [-179,180]
            //A[3] = A[3] * sign;

            // angle in [0,360] (not used but included here for completeness)
            //var angle360 =  (signed_angle + 180) % 360;


            // ---- check and flip A3 A4 if needed ----

//            var difference = current_A[ 3 ] - A[ 3 ];
//
//            if ( difference > 0.5 * Math.PI || difference < - 0.5 * Math.PI ) {
//                Serial.println( "----------- flipping A3 - distance closer -------------" );
//                Serial.println( "----------- A3 before " + floatToString( A[ 3 ] ) + " -------------" );
//                A[ 3 ] = (A[ 3 ] > 0.0) ? A[ 3 ] - Math.PI : A[ 3 ] + Math.PI;
//                //A[3] =  A[3] + 180.0;
//                A[ 4 ] = - A[ 4 ];
//                //A[4] = 0;
//            } else {
//                //Serial.println("----------- not flipping A3 - currentA3 " + floatToString(current_A[3]) + " ------------- A3 " + floatToString(A[3]));
//            }


            // ---- Error handling ----

            var error = false;

            for ( var a = 0; a < 5; a ++ ) {
                if ( isNaN( A[ a ] ) ) {
                    Serial.println( "E A_" + String( a ) + " out of reach " );
                    error = true;
                } else if ( A[ a ] < jointLimits[ a ][ 0 ] || A[ a ] > jointLimits[ a ][ 1 ] ) {
                    Serial.println( "E A_" + String( a ) + " out of bounds " + floatToString( A[ a ] / Math.PI * 180.0 ) );
                    Serial.println( "E A_" + String( a ) + " bounds " + floatToString( jointLimits[ a ][ 1 ] / Math.PI * 180.0 ) );
                    Serial.println( "E A_" + String( a ) + " bounds " + floatToString( jointLimits[ a ][ 0 ] / Math.PI * 180.0 ) );
                    error = true;
                }
            }

            if ( ! error || true ) {
                //todo set A . While moving, print to serial

                Serial.println( "A0 " + floatToString( A[ 0 ] ) );
                Serial.println( "A1 " + floatToString( A[ 1 ] ) );
                Serial.println( "A2 " + floatToString( A[ 2 ] ) );
                Serial.println( "A3 " + floatToString( A[ 3 ] ) );
                Serial.println( "A4 " + floatToString( A[ 4 ] ) );


                Serial.println( "JD X" + floatToString( normal_J2J4_zAxis[ 0 ] ) + " Y" + floatToString( normal_J2J4_zAxis[ 1 ] ) + " Z" + floatToString( normal_J2J4_zAxis[ 2 ] ) );
                Serial.println( "JE X" + floatToString( normal_J2J4_vector[ 0 ] ) + " Y" + floatToString( normal_J2J4_vector[ 1 ] ) + " Z" + floatToString( normal_J2J4_vector[ 2 ] ) );

                Serial.println( "J1 X" + floatToString( J[ 1 ][ 0 ] ) + " Y" + floatToString( J[ 1 ][ 1 ] ) + " Z" + floatToString( J[ 1 ][ 2 ] ) );
                Serial.println( "J2 X" + floatToString( J[ 2 ][ 0 ] ) + " Y" + floatToString( J[ 2 ][ 1 ] ) + " Z" + floatToString( J[ 2 ][ 2 ] ) );
                Serial.println( "J4 X" + floatToString( J[ 4 ][ 0 ] ) + " Y" + floatToString( J[ 4 ][ 1 ] ) + " Z" + floatToString( J[ 4 ][ 2 ] ) );

                target_A[ 0 ] = A[ 0 ];
                target_A[ 1 ] = A[ 1 ];
                target_A[ 2 ] = A[ 2 ];
                target_A[ 3 ] = A[ 3 ];
                target_A[ 4 ] = A[ 4 ];
                target_A[ 5 ] = A[ 5 ];
            } else {
//                STATE = END_MOVE;
            }
        }

        render();
    }


    // render the scene
    function render() {

        // actually render the scene
        renderer.render( scene, camera );
    }
</script>
</body>
</html>
